<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RN 学习</title>
    <url>/2021/06/02/RN-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><h3 id="RN调用原生"><a href="#RN调用原生" class="headerlink" title="RN调用原生"></a>RN调用原生</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.引用</span><br><span class="line">import &#123; NativeModules &#125; from <span class="string">'react-native'</span>;</span><br><span class="line">2.使用</span><br><span class="line">NativeModules.ToastExample.isShow(&#123;</span><br><span class="line">    <span class="comment"># 参数</span></span><br><span class="line">&#125;,res =&gt;&#123;</span><br><span class="line">    <span class="comment"># 回调方法</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># ToastExample 原生导出的包名</span></span><br><span class="line"><span class="comment"># 方法名</span></span><br></pre></td></tr></table></figure>
<h3 id="RN接收原生的通知"><a href="#RN接收原生的通知" class="headerlink" title="RN接收原生的通知"></a>RN接收原生的通知</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="RN动画"><a href="#RN动画" class="headerlink" title="RN动画"></a>RN动画</h2><h3 id="loading动画"><a href="#loading动画" class="headerlink" title="loading动画"></a>loading动画</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.引用</span><br><span class="line">    import &#123; Animated, Easing &#125; from <span class="string">'react-native'</span>;</span><br><span class="line">2.定义变量</span><br><span class="line">    this.springValue = new Animated.value(0);</span><br><span class="line">    this.spin = null;</span><br><span class="line">3.定义动画方法</span><br><span class="line">    loadingAnimated = () =&gt; &#123;</span><br><span class="line">        Animated.loop( // 无限循环</span><br><span class="line">            Animated.timing(this.springValue, &#123;</span><br><span class="line">                toValue: 1,</span><br><span class="line">                duration: 3000, // 动画时间</span><br><span class="line">                easing: Easing.linear,</span><br><span class="line">                useNativeDriver: <span class="literal">true</span>,</span><br><span class="line">                isInteraction: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ).start();</span><br><span class="line">        this.spin = this.springValue.interpolate(&#123;</span><br><span class="line">            inputRange: [0, 1],</span><br><span class="line">            outputRange: [<span class="string">'0deg'</span>, <span class="string">'360deg'</span>]</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">4.绑定动画</span><br><span class="line">    &lt;Animated.Image </span><br><span class="line">        style=&#123;[&#123; transform: [&#123; rotate: this.spin &#125;] &#125;, styles.itemImg]&#125; </span><br><span class="line">        <span class="built_in">source</span>=&#123;url&#125; </span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>feelingTone</title>
    <url>/2020/05/15/feelingTone/</url>
    <content><![CDATA[<blockquote>
<p>从来茶倒七分满，留下三分是人情。茶倒七分满，才不会水溢烫手。为人处事也是如此，饭要七分饱，话留三分好。半人半我半自在，半醒半醉半神仙。半亲半爱半苦乐，半俗半禅半随缘<br>人生最好的三个词：“久别重逢，失而复得，虚惊一场”却唯独没有一个词叫：“和好如初”。和好容易，如初多难啊<br>大事不糊涂，小事不计较</p>
</blockquote>
]]></content>
      <categories>
        <category>feeling</category>
      </categories>
      <tags>
        <tag>feeling</tag>
      </tags>
  </entry>
  <entry>
    <title>promises使用</title>
    <url>/2020/05/15/promises%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2019/12/18/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>mac显示隐藏文件夹操作</title>
    <url>/2019/12/18/mac%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>方法一：<br>        <kbd>command</kbd>+<kbd>shift</kbd>+<kbd>.</kbd></p>
</blockquote>
<blockquote>
<p>方法二：（需要重启Finder）</p>
</blockquote>
<pre><code>显示：defaults write com.apple.finder AppleShowAllFiles -bool true
隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false</code></pre><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>项目中常用的方法</title>
    <url>/2019/12/13/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="mock数据常用的数据填充"><a href="#mock数据常用的数据填充" class="headerlink" title="mock数据常用的数据填充"></a>mock数据常用的数据填充</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new Array(10).fill(&#123;name: <span class="string">'ayuan'</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="数组去重（简单数组）"><a href="#数组去重（简单数组）" class="headerlink" title="数组去重（简单数组）"></a>数组去重（简单数组）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const arr = [1,<span class="string">'1'</span>,1,2,<span class="string">'2'</span>,2,<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'ayuan'</span>,<span class="string">'ayuan'</span>,<span class="string">'a'</span>];</span><br><span class="line">functin <span class="function"><span class="title">setArr</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">console.log(setArr()); // [1, <span class="string">"1"</span>, 2, <span class="string">"2"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"ayuan"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="list去重合并code相同的meanu字段"><a href="#list去重合并code相同的meanu字段" class="headerlink" title="list去重合并code相同的meanu字段"></a>list去重合并code相同的meanu字段</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const nowJson = [ </span><br><span class="line">    &#123;menuCode: <span class="string">"651deb89ae9740eb96740aa802cdadff"</span>, permission: <span class="string">"look"</span>&#125;,</span><br><span class="line">    &#123;menuCode: <span class="string">"651deb89ae9740eb96740aa802cdadff"</span>, permission: <span class="string">"maintain"</span>&#125;,</span><br><span class="line">    &#123;menuCode: <span class="string">"651deb89ae9740eb96740aa802cdadff"</span>, permission: <span class="string">"import"</span>&#125;,</span><br><span class="line">    &#123;menuCode: <span class="string">"d0fe753fe4b844ccb2fcfa1875320f78"</span>, permission: <span class="string">"maintainall"</span>&#125;,</span><br><span class="line">    &#123;menuCode: <span class="string">"d0fe753fe4b844ccb2fcfa1875320f78"</span>, permission: <span class="string">"maintain"</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="built_in">let</span> <span class="built_in">hash</span> = &#123;&#125;,index = 0,newJson=[];</span><br><span class="line">newJson = nowJson.reduce((item, next) =&gt;&#123; </span><br><span class="line">    <span class="keyword">if</span> (hash.hasOwnProperty(next.menuCode)) &#123;</span><br><span class="line">        item[<span class="built_in">hash</span>[next.menuCode]].permission +=`,<span class="variable">$&#123;next.permission&#125;</span>`</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">hash</span>[next.menuCode] = index ++</span><br><span class="line">        item.push(next)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> item;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>
<h2 id="获取地址栏中的参数"><a href="#获取地址栏中的参数" class="headerlink" title="获取地址栏中的参数"></a>获取地址栏中的参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(variable) &#123;</span><br><span class="line">    const query = window.location.search.substring(1);</span><br><span class="line">    const vars = query.split(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; vars.length; i++) &#123;</span><br><span class="line">        const pair = vars[i].split(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">if</span> (pair[0] == variable) &#123;</span><br><span class="line">            <span class="built_in">return</span> pair[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="首尾去空格"><a href="#首尾去空格" class="headerlink" title="首尾去空格"></a>首尾去空格</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> trim(str) &#123;</span><br><span class="line">    <span class="built_in">return</span> typeOf str === <span class="string">'string'</span></span><br><span class="line">            ? str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, <span class="string">''</span>)</span><br><span class="line">            : str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="页面显示倒计时-react组件"><a href="#页面显示倒计时-react组件" class="headerlink" title="页面显示倒计时 (react组件)"></a>页面显示倒计时 (react组件)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from <span class="string">'react'</span></span><br><span class="line">class CountTime extends Component&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            HMS: <span class="string">''</span>,</span><br><span class="line">            counttime: 0</span><br><span class="line">        &#125;</span><br><span class="line">        this.timer = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">        this.countDate()</span><br><span class="line">        this.setCount()</span><br><span class="line">    &#125;</span><br><span class="line">    countDate = () =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>高程总结第三版</title>
    <url>/2019/12/12/%E9%AB%98%E7%A8%8B%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%89%E7%89%88/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p>1.数据类型</p>
<pre><code>undefined,boolean,string,number,object,function</code></pre><p>2.var a = null , typeof(a)为什么输出object?</p>
<pre><code>null类型是第二个只有一个值的数据类型（另一个是undefined），null表示一个空指针对象，所以使用typeof操作符检测输出为object</code></pre><p>3.为什么小数点后面没有跟数字（如：1.），或浮点值本身就是一个整数（如：1.0）这个值会作为一个整数保存?</p>
<pre><code>由于浮点值需要的存储空间是保存整数值的两倍，所以ECMAscript会不失时机的将浮点数值转换成整数</code></pre><p>4.两个浮点数相加会产生舍入误差的精度问题（浮点数最高的精度值是17位小数）</p>
<pre><code>如：
    a:0.1加0.2的结果不能与0.3，而是0.30000000000000004
    b:0.05+0.25结果为0.3</code></pre><p>5.ECMAScript并不能保存世界上所有的数值，能够表示的最小数值存在Number.MIN_VALUE中(5e-324),能够表示的最大的数值存在Number.MAX_VALUE中，如果某次计算的结果超出js数值范围，会被转成特殊的Infinity值（正无穷）-Infinity（负无穷)<br>6.如果某次计算返回了Infinity，则无法参与下次计算。如何判断数值是不是有穷的？</p>
<pre><code>使用isFinite()函数，返回true/false</code></pre><p>7.数值转换</p>
<pre><code>- 非数值转成数值：Number() -- 适用于任何数据类型；parseInt() -- 适用于字符串转数值；parseFloat()  -- 适用于字符串转数值；
    tips：这三个函数对于同样的输入会返回不一样的结果
    例如：
        const a = &apos;1a1&apos;;
        Number(a);          // NaN
        parseInt(a);        // 1
        parseFloat(a);      // 1
    Number()函数的转换规则
        1）如果是Boolean值，true和false分别转换成1和0
        2）如果是数字只是简单的输入输出
        3）如果是null输出0
        4）如果是undefined，返回NaN
        5）如果是字符串 Number(&quot;111&quot;) // 111 
              Number(&quot;011&quot;)           // 11 
              Number(&quot;1.1&quot;)           // 1.1 
              Number(&quot;&quot;)              // 0 
              Number(&quot;1a1&quot;)           // NaN
          6）如果是对象，先调用valueOf()方法在调用toString()方法
    parseInt()函数在转换字符串是，会忽略字符串前的空格，如果第一个字符不是数字字符或者符号，则返回NaN。这个函数可以识别十进制，八进制和十六进制
    parseFloat()函数和parseInt()函数类似，区别是：字符串中第一个小数点是有效的，第二个无效；只能解析十进制</code></pre><p>8.字符串转换</p>
<pre><code>- 数值，布尔值，对象和字符串都有toString()方法。字符串返回字符串的一个副本。但是null和undefined值没有这个方法。
      tips: 在不知道要转换的值是否为null或者undefined时，可以使用转型函数String()遵循的规则为：
          a）如果值有toString()方法调用该方法，返回相应的结果
          b）如果值为null则返回null
          c）如果值为undefined则返回undefined</code></pre></blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的兼容性处理</title>
    <url>/2019/12/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="git请求在IE浏览器的缓存问题"><a href="#git请求在IE浏览器的缓存问题" class="headerlink" title="git请求在IE浏览器的缓存问题"></a>git请求在IE浏览器的缓存问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">多加一个时间戳参数：new Date().getTime()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的css样式总结</title>
    <url>/2019/12/12/%E5%B8%B8%E7%94%A8%E7%9A%84css%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="背景图全屏处理"><a href="#背景图全屏处理" class="headerlink" title="背景图全屏处理"></a>背景图全屏处理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">html &#123; </span><br><span class="line">    background: url(<span class="string">'bg.jpg'</span>) no-repeat center center fixed; </span><br><span class="line">    background-size: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="上下左右垂直剧中"><a href="#上下左右垂直剧中" class="headerlink" title="上下左右垂直剧中"></a>上下左右垂直剧中</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.center&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单行文本超出省略号显示"><a href="#单行文本超出省略号显示" class="headerlink" title="单行文本超出省略号显示"></a>单行文本超出省略号显示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.textEllipsis&#123;</span><br><span class="line">    width: 65px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    line-height: 30px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多行文本超出省略号显示"><a href="#多行文本超出省略号显示" class="headerlink" title="多行文本超出省略号显示"></a>多行文本超出省略号显示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.textEllipsis&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    overflow : hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: 2;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="禁止点击"><a href="#禁止点击" class="headerlink" title="禁止点击"></a>禁止点击</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.noClick&#123;</span><br><span class="line">    pointer-events: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片变灰白色"><a href="#图片变灰白色" class="headerlink" title="图片变灰白色"></a>图片变灰白色</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.imageGray&#123;</span><br><span class="line">    filter: gray;</span><br><span class="line">    -webkit-filter: grayscale(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="长文本自动换行"><a href="#长文本自动换行" class="headerlink" title="长文本自动换行"></a>长文本自动换行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.lineFeed&#123;</span><br><span class="line">    white-space: pre-line;</span><br><span class="line">    word-wrap: <span class="built_in">break</span>-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模糊文本"><a href="#模糊文本" class="headerlink" title="模糊文本"></a>模糊文本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.mh&#123;</span><br><span class="line">    filter: blur(1px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移动端样式"><a href="#移动端样式" class="headerlink" title="移动端样式"></a>移动端样式</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/2019/12/10/interview/</url>
    <content><![CDATA[<h2 id="js常见问题"><a href="#js常见问题" class="headerlink" title="js常见问题"></a>js常见问题</h2><h3 id="null-和-undefined的区别"><a href="#null-和-undefined的区别" class="headerlink" title="null 和 undefined的区别"></a>null 和 undefined的区别</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.null是原型链的终点，属于object类型</span><br><span class="line">    Object.prototype._proto_ === null</span><br><span class="line">2.undefined 是一个单独的类型，这个类型只有一个值为undefined</span><br><span class="line">    undefined 表示一个变量未定义，或者调用了一个没有<span class="built_in">return</span>值的<span class="keyword">function</span></span><br><span class="line">undefined 继承于null</span><br></pre></td></tr></table></figure>
<h3 id="原型，原型链"><a href="#原型，原型链" class="headerlink" title="原型，原型链"></a>原型，原型链</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">原型：每个对象都有自己的原型对象，它可以使用自己原型对象上的所有属性和方法</span><br><span class="line">获取原型对象两种方法，__proto__  构造函数的 prototype</span><br><span class="line">构造函数：</span><br><span class="line"><span class="keyword">function</span> Cat (name,age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> cat = new Cat();</span><br><span class="line">Cat.prototype.sex = “女”</span><br><span class="line">prototype（原型），每个对象都会在自己的内部初始化一个原型。</span><br><span class="line">当我们访问一个对象的某个属性时，对象的内部没有这个属性就会去prototype中寻找，没有找到会继续找自己上一级的prototype。这个查找的过程叫做原型链。</span><br><span class="line">如果查不到返回null。</span><br></pre></td></tr></table></figure>
<h3 id="webpack-module-chunk-bundle"><a href="#webpack-module-chunk-bundle" class="headerlink" title="webpack module chunk bundle"></a>webpack module chunk bundle</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">module: 在项目中一层层的引用关系webpack会按照层级结构去构建一个tree结构，构成tree结构的每一个节点被称为module（js和被js组织起来的任意文件）</span><br><span class="line">chunk: 项目中一层层引用关系被webpack组建成了也个tree，这个tree被称为chunk（被js组织起来的文件依赖结构）</span><br><span class="line">bundle: 拿到依赖结构去打包最终输出的js文件</span><br></pre></td></tr></table></figure>
<h3 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    常用的插件</span><br><span class="line">    CleanWebpackPlugin // 每次打包的时候对dist文件做一个清除</span><br><span class="line">    HtmlWebpackPlugin // 帮我们自动的生成一个dist目录下的html文件</span><br><span class="line">    HotModuleReplacementPlugin // 热更新</span><br><span class="line">    splitChunksPlugin： // 代码分割 </span><br><span class="line">        // 引入的模块，只有大于30kb时，才会做代码分割</span><br><span class="line">        minSize: 30000,</span><br><span class="line">         // 引入的模块，如果大于50kb时，进行二次分割，分成多个文件</span><br><span class="line">        maxSize: 50000,</span><br><span class="line">        // 当模块的引入次数大于或等于1时，才会进行代码分割</span><br><span class="line">        minChunks: 1,</span><br><span class="line">    tree </span><br><span class="line"></span><br><span class="line">    treeshking是减小打包的bundle size很重要的一个手段，但触发treeshking是有条件的，首先需要代码是es module规范的并且使用解构赋值的方式引入，第二要开始optimization.usedExports来标记使用和未使用的模块，第三是使用压缩的插件进行删除未使用代码。 webpack4的mode设置为production之后，我们只需要关心第一点就好了。</span><br><span class="line">使用了externals将第三方库以cdn的方式去引入</span><br><span class="line"></span><br><span class="line"> ```   </span><br><span class="line"> <span class="comment">### vue自定义指令</span></span><br><span class="line"> ```bash</span><br><span class="line">    vuex-persistedstate</span><br></pre></td></tr></table></figure>
<h3 id="如何解决vuex项目刷新页面导致的状态数据丢失的问题"><a href="#如何解决vuex项目刷新页面导致的状态数据丢失的问题" class="headerlink" title="如何解决vuex项目刷新页面导致的状态数据丢失的问题"></a>如何解决vuex项目刷新页面导致的状态数据丢失的问题</h3><p> 　<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="简述vue的响应式原理"><a href="#简述vue的响应式原理" class="headerlink" title="简述vue的响应式原理"></a>简述vue的响应式原理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. data属性被转换为getter和setter，并且记录相应的依赖，当数据改变时会通知相应的依赖</span><br><span class="line">2. 所有的组件实例都有一个对应的watcher实例，watcher实例会依赖于相应的setter实例</span><br><span class="line">3. 当数据变化时setter会被调用然后setter会通知相应的watcher，watcher会更新相应的视图</span><br></pre></td></tr></table></figure>
<h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">浏览器的同源策略，域名，协议，端口号任意一个不同属于不同源，不同源不允许获取资源</span><br><span class="line">解决跨域：</span><br><span class="line">    1、 通过jsonp跨域</span><br><span class="line">    2、 document.domain + iframe跨域</span><br><span class="line">    3、 location.hash + iframe</span><br><span class="line">    4、 window.name + iframe跨域</span><br><span class="line">    5、 postMessage跨域</span><br><span class="line">    6、 跨域资源共享（CORS）</span><br><span class="line">    7、 nginx代理跨域</span><br><span class="line">    8、 nodejs中间件代理跨域</span><br><span class="line">    9、 WebSocket协议跨域</span><br></pre></td></tr></table></figure>
<h3 id="vuex刷新页面数据丢失解决方案"><a href="#vuex刷新页面数据丢失解决方案" class="headerlink" title="vuex刷新页面数据丢失解决方案"></a>vuex刷新页面数据丢失解决方案</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.vuex的store数据和本地缓存数据绑定，保存在vuex里的数据也在本地缓存中绑定一份</span><br><span class="line">2.使用第三方插件：npm install vuex-persistedstate --save</span><br><span class="line">    默认持久化所有的数据，也可已指定部分</span><br></pre></td></tr></table></figure>
<h3 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="说说useEffect，参数和没有参数的区别"><a href="#说说useEffect，参数和没有参数的区别" class="headerlink" title="说说useEffect，参数和没有参数的区别"></a>说说useEffect，参数和没有参数的区别</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="深拷贝和浅拷贝的理解"><a href="#深拷贝和浅拷贝的理解" class="headerlink" title="深拷贝和浅拷贝的理解"></a>深拷贝和浅拷贝的理解</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">区别：</span><br><span class="line">    浅拷贝只是将原对象的引用复制给了新的对象，与原对象公用一个内存空间，会随原对象变动</span><br><span class="line">    深拷贝是将原对象的引用复制给新对象并重新分配内存空间，独立于原对象</span><br><span class="line">浅拷贝：</span><br><span class="line">    对象A=对象B</span><br><span class="line">    Object.assign(&#123;name:<span class="string">'ayuan'</span>,&#123;name:<span class="string">'lele'</span>,age:3&#125;&#125;) =&gt; 输出结果 &#123;name:<span class="string">'lele'</span>,age:3&#125;</span><br><span class="line">深拷贝：</span><br><span class="line">    JSON.parase(JSON.stringify(json))  =&gt; 简单粗暴</span><br><span class="line">    js封装方法：</span><br><span class="line">        <span class="keyword">function</span> deepCopy（p,c）&#123;</span><br><span class="line">            c = c || [];</span><br><span class="line">            <span class="keyword">for</span>(const i <span class="keyword">in</span> p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (typeof p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                    c[i] = Object.prototype.toSting.call(p[i]) === ‘[object Array]’ ? [] : &#123;&#125;</span><br><span class="line">                    deepCopy(p[i],c[i])</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    c[i] = p[i]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> c</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="web离线存储介绍"><a href="#web离线存储介绍" class="headerlink" title="web离线存储介绍"></a>web离线存储介绍</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">离线存储：cookie，localStorage,sessionStorage</span><br><span class="line">区别：</span><br><span class="line">    -   存储大小：cookie不能超过4k，localStorage和sessionStorage是5M</span><br><span class="line">    -   有效时间：cookie设置了有效时间后在有效时间内一直有效，即使关闭浏览器或关闭窗口也不会被删除；localStorage存储持久数据，浏览器关闭数据不丢失除非主动删除；sessionStorage数据不持久，关闭浏览器数据自动删除</span><br><span class="line">    -   与服务器之间的关系：cookie会将数据传递到服务端，服</span><br><span class="line">cookie的sameSite属性：</span><br><span class="line">    -   作用：可以让cookie在跨站请求时不会被发送可以阻止跨站请求伪造攻击（CSRF）</span><br><span class="line">    -   参数：Strict：仅允许一方请求携带cookie（浏览器将只发送相同站点请求的cookie，即当前网页的url与请求目标url完全一致）。</span><br><span class="line">                Lax：允许部分第三方请求携带cookie</span><br><span class="line">               None：无论是否跨站都会发送cookie</span><br><span class="line">    -   变化：2020年2月发布的Chrome80 版本中默认屏蔽了第三方的Cookie。之前默认是 None 的，Chrome80 后默认是 Lax。</span><br><span class="line">cookie的HTTPOnly属性</span><br><span class="line">    -   作用：可以防止客户端脚本通过document.cookie等方式访问cookie，有助于避免XSS攻击</span><br></pre></td></tr></table></figure>
<h3 id="数组常用的操作方法"><a href="#数组常用的操作方法" class="headerlink" title="数组常用的操作方法"></a>数组常用的操作方法</h3><p><img src="/2019/12/10/interview/ArrImg.png" alt="ArrImg"></p>
<h3 id="call-，apply-bind-的区别"><a href="#call-，apply-bind-的区别" class="headerlink" title="call()，apply(),bind()的区别"></a>call()，apply(),bind()的区别</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">首先这三个都是用来改变this指向的。</span><br><span class="line">区别：call()和apply()第一个参数都是指定的对象，call之后的参数都是传入该函数的值，apply第二个参数是数组，数组中是函数执行需要的参数。</span><br><span class="line"><span class="built_in">bind</span>()的参数和call相同，不同的是<span class="built_in">bind</span>改变this的指向后不会立即执行函数，其他两个是改变后立即执行的</span><br><span class="line">tips：</span><br><span class="line">    使用<span class="built_in">bind</span>()的时候最好不要直接绑定在dome上，以react为例最好在constructor中使用。避免当dome变化时需重新绑定，写法如下:</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/10/interview/bind()%E4%BC%98%E5%8C%96.png" alt="bind()优化"></p>
<h3 id="const定义的变量可以改变吗"><a href="#const定义的变量可以改变吗" class="headerlink" title="const定义的变量可以改变吗"></a>const定义的变量可以改变吗</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const定义的变量是个常量不可修改，但是如果const定义了一个对象，可以改变对象里的属性</span><br></pre></td></tr></table></figure>

<h3 id="对Object-assign-的理解"><a href="#对Object-assign-的理解" class="headerlink" title="对Object.assign()的理解"></a>对Object.assign()的理解</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Object.assign()合并对象，第一个参数是目标对象，剩余是源对象。</span><br><span class="line">如果多个源对象有相同属性，后边的源对象会覆盖前边的属性</span><br></pre></td></tr></table></figure>
<h3 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）typeof （不能区分Object，Array，null）</span><br><span class="line">    console.log(typeof 1);               // number</span><br><span class="line">    console.log(typeof <span class="literal">false</span>);           // boolean</span><br><span class="line">    console.log(typeof <span class="string">'string'</span>);        // string</span><br><span class="line">    console.log(typeof undefined);       // undefined</span><br><span class="line">    console.log(typeof []);              // object </span><br><span class="line">    console.log(typeof &#123;&#125;);              // object</span><br><span class="line">    console.log(typeof <span class="function"><span class="title">function</span></span>()&#123;&#125;);    // <span class="keyword">function</span></span><br><span class="line">    console.log(typeof null);            // object</span><br><span class="line">（2）instanceof（不能区分Number，Boolean，String）</span><br><span class="line">    console.log(1 instanceof Number);                    // <span class="literal">false</span></span><br><span class="line">    console.log(<span class="literal">false</span> instanceof Boolean);               // <span class="literal">false</span> </span><br><span class="line">    console.log(<span class="string">'string'</span> instanceof String);             // <span class="literal">false</span>  </span><br><span class="line">    console.log([] instanceof Array);                    // <span class="literal">true</span></span><br><span class="line">    console.log(<span class="function"><span class="title">function</span></span>()&#123;&#125; instanceof Function);       // <span class="literal">true</span></span><br><span class="line">    console.log(&#123;&#125; instanceof Object);                   // <span class="literal">true</span></span><br><span class="line">（3）Object.prototype.toString.call() （建议封装过后使用）</span><br><span class="line">    var toString = Object.prototype.toString;</span><br><span class="line">    console.log(toString.call(1));                      //[object Number]</span><br><span class="line">    console.log(toString.call(<span class="literal">false</span>));                  //[object Boolean]</span><br><span class="line">    console.log(toString.call(<span class="string">'string'</span>));               //[object String]</span><br><span class="line">    console.log(toString.call([]));                     //[object Array]</span><br><span class="line">    console.log(toString.call(<span class="function"><span class="title">function</span></span>()&#123;&#125;));           //[object Function]</span><br><span class="line">    console.log(toString.call(&#123;&#125;));                     //[object Object]</span><br><span class="line">    console.log(toString.call(undefined));              //[object Undefined]</span><br><span class="line">    console.log(toString.call(null));                   //[object Null]</span><br></pre></td></tr></table></figure>
<h3 id="判断下面等式真假"><a href="#判断下面等式真假" class="headerlink" title="判断下面等式真假"></a>判断下面等式真假</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[] == <span class="string">''</span>            // <span class="literal">true</span></span><br><span class="line">[] === <span class="string">''</span>           // <span class="literal">false</span></span><br><span class="line">&#123;&#125; == &#123;&#125;            // <span class="literal">false</span></span><br><span class="line">&#123;&#125; === &#123;&#125;           // <span class="literal">false</span></span><br><span class="line">null == undefined   // <span class="literal">true</span></span><br><span class="line">null === undefined  // <span class="literal">false</span></span><br><span class="line">NaN != NaN          // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="Promise的使用"><a href="#Promise的使用" class="headerlink" title="Promise的使用"></a>Promise的使用</h3><h3 id="怎么解决ie与低版本浏览器es6兼容问题"><a href="#怎么解决ie与低版本浏览器es6兼容问题" class="headerlink" title="怎么解决ie与低版本浏览器es6兼容问题"></a>怎么解决ie与低版本浏览器es6兼容问题</h3><blockquote>
<p>1.安装babel-polyfill</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i babel-polyfill -S</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.在入口文件引入abel-polyfill</p>
</blockquote>
<h2 id="vue相关问题"><a href="#vue相关问题" class="headerlink" title="vue相关问题"></a>vue相关问题</h2><h3 id="ajax请求一般放在哪个生命周期中"><a href="#ajax请求一般放在哪个生命周期中" class="headerlink" title="ajax请求一般放在哪个生命周期中"></a>ajax请求一般放在哪个生命周期中</h3><h3 id="什么场景下会用到beforeDestory"><a href="#什么场景下会用到beforeDestory" class="headerlink" title="什么场景下会用到beforeDestory"></a>什么场景下会用到beforeDestory</h3><h3 id="父子组件的调用顺序"><a href="#父子组件的调用顺序" class="headerlink" title="父子组件的调用顺序"></a>父子组件的调用顺序</h3><blockquote>
<p>父组件先开始自己的created，然后子组件开始自己的created和mounted，最后父组件再执行自己的mounted</p>
</blockquote>
<h3 id="computed的特点"><a href="#computed的特点" class="headerlink" title="computed的特点"></a>computed的特点</h3><blockquote>
<p>1.在引用时不需要加(),直接把他当成普通的属性去用<br>2.只要数据变化就会立即执行<br>3.求值结果会被缓存起来，方便下次直接使用</p>
</blockquote>
<h3 id="为什么v-for和v-if不能连用"><a href="#为什么v-for和v-if不能连用" class="headerlink" title="为什么v-for和v-if不能连用"></a>为什么v-for和v-if不能连用</h3><blockquote>
<p>当它们处于同一节点 v-for指令的优先级高于v-if,这意味着 v-if 将分别重复运行于每个 v-for 循环中</p>
</blockquote>
<h3 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">v-if 会控制这个dom节点是否存在</span><br><span class="line">v-show 控制dom的显示方式，控制display属性在none和block之间切换</span><br><span class="line">如果经常切换元素的显隐用v-show更加节省性能</span><br><span class="line">如果只需要一次显隐的话使用v-if</span><br></pre></td></tr></table></figure>
<h3 id="v-for为什么要配合key使用"><a href="#v-for为什么要配合key使用" class="headerlink" title="v-for为什么要配合key使用"></a>v-for为什么要配合key使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">key的作用</span><br></pre></td></tr></table></figure>
<h3 id="slot的使用，什么是作用域插槽"><a href="#slot的使用，什么是作用域插槽" class="headerlink" title="slot的使用，什么是作用域插槽"></a>slot的使用，什么是作用域插槽</h3><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h2 id="react相关问题"><a href="#react相关问题" class="headerlink" title="react相关问题"></a>react相关问题</h2><h3 id="ajax-请求放在-componentDidMount-里进行处理还是放在componentWillMount-里进行处理比较合适"><a href="#ajax-请求放在-componentDidMount-里进行处理还是放在componentWillMount-里进行处理比较合适" class="headerlink" title="ajax 请求放在 componentDidMount 里进行处理还是放在componentWillMount 里进行处理比较合适"></a>ajax 请求放在 componentDidMount 里进行处理还是放在componentWillMount 里进行处理比较合适</h3><h3 id="setState异步处理除了放在回调中还有什么方法"><a href="#setState异步处理除了放在回调中还有什么方法" class="headerlink" title="setState异步处理除了放在回调中还有什么方法"></a>setState异步处理除了放在回调中还有什么方法</h3><h3 id="React-应用如何在重新加载页面时保留数据"><a href="#React-应用如何在重新加载页面时保留数据" class="headerlink" title="React 应用如何在重新加载页面时保留数据"></a>React 应用如何在重新加载页面时保留数据</h3><h3 id="Redux-的三大原则"><a href="#Redux-的三大原则" class="headerlink" title="Redux 的三大原则"></a>Redux 的三大原则</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">单一数据源</span><br><span class="line">state是只读的</span><br><span class="line">通过纯函数修改</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>/2019/11/14/myBlog/</url>
    <content><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><blockquote>
<p>1.安装git，如何安装请参考<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a><br>2.安装node，如何安装请参考<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node官网</a><br>3.准备gitHub账号，请前往<a href="https://github.com/" target="_blank" rel="noopener">gitHub官网</a>设置账号</p>
</blockquote>
<h2 id="参考记录"><a href="#参考记录" class="headerlink" title="参考记录"></a>参考记录</h2><blockquote>
<p>1.<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT官网</a><br>2.<a href="http://xyua.top/" target="_blank" rel="noopener">雜言非語</a><br>3.<a href="https://www.qcmoke.site/blog/hexo_next.html" target="_blank" rel="noopener">Qcmoke’s Blog</a></p>
</blockquote>
<h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1 使用git执行以下命令(方便更新):</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line"><span class="comment"># 方法2 直接下载稳定版本</span></span><br><span class="line">选择你所需要的版本，下载 Download 区域下的 Source Code (zip) 到本地。</span><br><span class="line">解压所下载的压缩包至站点的 themes 目录下， 并将 解压后的文件夹名称（hexo-theme-next-0.4.0）更改为 hexo-theme-next</span><br></pre></td></tr></table></figure>
<h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><blockquote>
<p>1.在 myblog/_config.yml中搜索关键字：theme<br>2.将 theme: landscape 修改为 theme: hexo-theme-next</p>
</blockquote>
<p><img src="/2019/11/14/myBlog/editTheme.png" alt="editTheme"></p>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><h4 id="语言配置"><a href="#语言配置" class="headerlink" title="语言配置"></a>语言配置</h4><blockquote>
<p>1.在 myblog/_config.yml中搜索关键字：language<br>2.将 language:  修改为 language: zh-Hans</p>
</blockquote>
<p><img src="/2019/11/14/myBlog/editLanguage.png" alt="editLanguage"></p>
<h4 id="配置图片"><a href="#配置图片" class="headerlink" title="配置图片"></a>配置图片</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.npm install hexo-asset-image --save</span><br><span class="line">2.修改_config.yml将post_asset_folder的值设为<span class="literal">true</span>（post_asset_folder: <span class="literal">true</span>）</span><br><span class="line">3.若遇到图片无法显示问题，查看生成的图片资源前缀是否无日期，若无日期修改hexo-asset-image下index.js文件</span><br><span class="line">    添加：var version = String(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">    修改：<span class="keyword">if</span> (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">            var beginPos = getPosition(link, <span class="string">'/'</span>, 1) + 1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            var beginPos = getPosition(link, <span class="string">'/'</span>, 3) + 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/14/myBlog/hexo-asset-image.png" alt="hexoImage"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的git命令</title>
    <url>/2019/06/28/gitUse/</url>
    <content><![CDATA[<blockquote>
<p>克隆代码：</p>
<pre><code>git clone [url]</code></pre><p>查看本地更新状态:</p>
<pre><code>git status</code></pre><p>添加文件:</p>
<pre><code>git add [name] // 添加某个文件
git add .      // 添加所有文件</code></pre><p>添加commit信息:</p>
<pre><code>git commit -m &quot;更新的内容&quot;
git commit -v  // 查看记录</code></pre><p>更新代码：</p>
<pre><code>git pull origin master // 从master分支上更新代码</code></pre><p>推送至远程仓库:</p>
<pre><code>git push origin master </code></pre></blockquote>
<h1 id="git操作远程仓库分支"><a href="#git操作远程仓库分支" class="headerlink" title="git操作远程仓库分支"></a>git操作远程仓库分支</h1><blockquote>
<p>查看远程仓库和本地仓库分支：</p>
<pre><code>git branch -a     // 查看所有分支
git branch        // 查看本地分支
git branch -r     // 查看远程分支
git branch [name] // 创建本地分支</code></pre><p>切换分支:（创建分支后要执行git push origin dev命令，将新分支推到远程）</p>
<pre><code>git checkout dev     // 切换至dev分支
git checkout -b dev  // 如果有dev分支切换至dev分支，如果没有则创建并切换至dev分支
git checkout -b dev origin/master // 基于master创建dev分支</code></pre><p>删除分支:</p>
<pre><code>git branch -d dev            // 删除本地dev分支，如果有未提交的代码则删除失败
git branch -D dev            // 强制删除本地dev分支
git push origin -d dev       // 删除远程分支dev</code></pre><p>合并分支:</p>
<pre><code>git checkout master // 第一步先切回主分支
git merge dev       // 第二步合并dev分支至master，如果有冲突需要先解决冲突</code></pre></blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常用的操作</title>
    <url>/2019/06/25/index/</url>
    <content><![CDATA[<h2 id="配置淘宝镜像"><a href="#配置淘宝镜像" class="headerlink" title="配置淘宝镜像"></a>配置淘宝镜像</h2><p>1.安装 nrm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm i -g nrm       // 全局安装nrm</span><br><span class="line">nrm ls                  // 查看可用的镜像</span><br><span class="line">nrm use taobao          // 使用淘宝镜像</span><br><span class="line">npm config get registry // 查看配置是否成功</span><br></pre></td></tr></table></figure>

<p>2.如果第一步不成功先安装 cnpm，使用 cnpm 安装 nrm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm config get registry // 验证是否设置成功</span><br></pre></td></tr></table></figure>

<h2 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h2><p>1.查看是否存在 ssh(如果有信息返回则不需要步骤 2)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ls || ll</span><br></pre></td></tr></table></figure>

<p>2.生成 ssh(如果上一步返回信息可忽略此步骤)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"name@XXX.com"</span></span><br></pre></td></tr></table></figure>

<p>3.拷贝 ssh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<h2 id="快速删除-node-modules"><a href="#快速删除-node-modules" class="headerlink" title="快速删除 node_modules"></a>快速删除 node_modules</h2><p>1.rimraf 删除 node_modules(速度最快)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install -g rimraf       // 全局安装rimraf</span><br><span class="line">rimraf node_modules</span><br></pre></td></tr></table></figure>

<p>2.第二种方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f /node_modules</span><br></pre></td></tr></table></figure>

<p>3.第三种方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmdir /s/q node_modules</span><br><span class="line">tips：</span><br><span class="line">    /s 是代表删除所有子目录跟其中的档案。</span><br><span class="line">    /q 是不要它在删除档案或目录时，不再问我 Yes or No 的动作。</span><br><span class="line">    要删除的目录前也可以指定路径，如： rmdir /s/q d:\123\abc</span><br></pre></td></tr></table></figure>

<h2 id="在-mac-上-npm-报权限问题"><a href="#在-mac-上-npm-报权限问题" class="headerlink" title="在 mac 上 npm 报权限问题"></a>在 mac 上 npm 报权限问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在终端输入命令： sudo chown -R <span class="variable">$USER</span> /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
